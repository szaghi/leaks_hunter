### Leaks hunter

> hunter of Fortran Compilers memory leaks

---

#### Why?

To perform a deeper analysis of GNU gfortran [bug 80477](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80477):

> memory leaks **could** be generated by polymorphic results of functions (the common scenario OOP operators). In particular, the memory leaks seem to be very sensible to the definitions of the *main type* components, e.g. it seems that if components are defined *static*, *allocatable*, *intrinsic*, *derived*, *polymorphic* or any combinations of them, the generation of memory leaks vary.

#### Copyrights

> Unlicensed.

---

#### Results

The analysis is performed by means of a very simple tests that could raise the memory leaks under different conditions:

+ [static components intrinsic](#static_components_intrinsic)
+ [static components derived](#static_components_derived)
+ [dynamic components intrinsic](#dynamic_components_intrinsic)
+ [dynamic components derived](#dynamic_components_derived)
+ [polymorphic components](#polymorphic_components)
+ [complex inheritance](#complex_inheritance)
+ [workaround](#workaround)
+ [multiple inheritance: workaround failing](multiple_inheritance)
+ [conclusions](#conclusions)

To compile, run and analyze the leaks generation the scripts contained into `scripts/` directory have been used, namely:

```bash
→ cat scripts/compile.sh
#!/usr/bin/env bash

rm -f a.out
gfortran -C -g -W -fbacktrace $1
rm -f *.mod

→ cat scripts/run_valgrind.sh
#!/usr/bin/env bash

valgrind --leak-check=full --show-leak-kinds=all -v a.out

→ cat scripts/dump_original.sh
#!/usr/bin/env bash

rm -f a.out
gfortran -fdump-tree-original $1
rm -f *.mod
```

---

##### static components intrinsic

> This seems to be the **main** source of leaks.

###### test code

```fortran
module static_intrinsic_type_m
   implicit none
   type :: static_intrinsic_type_t
      integer :: x
   contains
      generic :: assignment(=) => assign_static_intrinsic_type
      generic :: operator(+) => add_static_intrinsic_type
      procedure, pass(lhs) :: assign_static_intrinsic_type
      procedure, pass(lhs) :: add_static_intrinsic_type
   endtype static_intrinsic_type_t
contains
   subroutine assign_static_intrinsic_type(lhs, rhs)
      ! Operator `=`.
      class(static_intrinsic_type_t), intent(inout) :: lhs
      class(static_intrinsic_type_t), intent(in)    :: rhs
      lhs%x = rhs%x
   endsubroutine assign_static_intrinsic_type

   function add_static_intrinsic_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(static_intrinsic_type_t), intent(in)  :: lhs
      class(static_intrinsic_type_t), intent(in)  :: rhs
      class(static_intrinsic_type_t), allocatable :: res
      allocate (static_intrinsic_type_t :: res)
      res%x = lhs%x + rhs%x
   endfunction add_static_intrinsic_type
endmodule static_intrinsic_type_m
```

###### valgrind log

```
==19667== Memcheck, a memory error detector
==19667== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==19667== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==19667== Command: a.out
==19667==
--19667-- Valgrind options:
--19667--    --leak-check=full
--19667--    --show-leak-kinds=all
--19667--    -v
--19667-- Contents of /proc/version:
--19667--   Linux version 4.4.0-72-generic (buildd@lcy01-17) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) #93-Ubuntu SMP Fri Mar 31 14:07:41 UTC 2017
--19667--
--19667-- Arch and hwcaps: AMD64, LittleEndian, amd64-cx16-lzcnt-rdtscp-sse3-avx-avx2-bmi
--19667-- Page sizes: currently 4096, max supported 4096
--19667-- Valgrind library directory: /usr/lib/valgrind
--19667-- Reading syms from /home/stefano/leaks_hunter/a.out
--19667-- Reading syms from /lib/x86_64-linux-gnu/ld-2.23.so
--19667--   Considering /lib/x86_64-linux-gnu/ld-2.23.so ..
--19667--   .. CRC mismatch (computed 10768843 wanted ef0d0121)
--19667--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/ld-2.23.so ..
--19667--   .. CRC is valid
--19667-- Reading syms from /usr/lib/valgrind/memcheck-amd64-linux
--19667--   Considering /usr/lib/valgrind/memcheck-amd64-linux ..
--19667--   .. CRC mismatch (computed 5529a2c7 wanted 5bd23904)
--19667--    object doesn't have a symbol table
--19667--    object doesn't have a dynamic symbol table
--19667-- Scheduler: using generic scheduler lock implementation.
--19667-- Reading suppressions file: /usr/lib/valgrind/default.supp
==19667== embedded gdbserver: reading from /tmp/vgdb-pipe-from-vgdb-to-19667-by-stefano-on-thor
==19667== embedded gdbserver: writing to   /tmp/vgdb-pipe-to-vgdb-from-19667-by-stefano-on-thor
==19667== embedded gdbserver: shared mem   /tmp/vgdb-pipe-shared-mem-vgdb-19667-by-stefano-on-thor
==19667==
==19667== TO CONTROL THIS PROCESS USING vgdb (which you probably
==19667== don't want to do, unless you know exactly what you're doing,
==19667== or are doing some strange experiment):
==19667==   /usr/lib/valgrind/../../bin/vgdb --pid=19667 ...command...
==19667==
==19667== TO DEBUG THIS PROCESS USING GDB: start GDB like this
==19667==   /path/to/gdb a.out
==19667== and then give GDB the following command
==19667==   target remote | /usr/lib/valgrind/../../bin/vgdb --pid=19667
==19667== --pid is optional if only one valgrind process is running
==19667==
--19667-- REDIR: 0x401cdc0 (ld-linux-x86-64.so.2:strlen) redirected to 0x3809e181 (???)
--19667-- Reading syms from /usr/lib/valgrind/vgpreload_core-amd64-linux.so
--19667--   Considering /usr/lib/valgrind/vgpreload_core-amd64-linux.so ..
--19667--   .. CRC mismatch (computed a30c8eaa wanted 7ae2fed4)
--19667--    object doesn't have a symbol table
--19667-- Reading syms from /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so
--19667--   Considering /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so ..
--19667--   .. CRC mismatch (computed 402c2ab5 wanted 745f25ae)
--19667--    object doesn't have a symbol table
==19667== WARNING: new redirection conflicts with existing -- ignoring it
--19667--     old: 0x0401cdc0 (strlen              ) R-> (0000.0) 0x3809e181 ???
--19667--     new: 0x0401cdc0 (strlen              ) R-> (2007.0) 0x04c31020 strlen
--19667-- REDIR: 0x401b710 (ld-linux-x86-64.so.2:index) redirected to 0x4c30bc0 (index)
--19667-- REDIR: 0x401b930 (ld-linux-x86-64.so.2:strcmp) redirected to 0x4c320d0 (strcmp)
--19667-- REDIR: 0x401db20 (ld-linux-x86-64.so.2:mempcpy) redirected to 0x4c35270 (mempcpy)
--19667-- Reading syms from /usr/lib/x86_64-linux-gnu/libgfortran.so.3.0.0
--19667--   Considering /usr/lib/x86_64-linux-gnu/libgfortran.so.3.0.0 ..
--19667--   .. CRC mismatch (computed 86b8d083 wanted fa80e963)
--19667--    object doesn't have a symbol table
--19667-- Reading syms from /lib/x86_64-linux-gnu/libc-2.23.so
--19667--   Considering /lib/x86_64-linux-gnu/libc-2.23.so ..
--19667--   .. CRC mismatch (computed f3344b67 wanted 8e4ae80b)
--19667--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so ..
--19667--   .. CRC is valid
--19667-- Reading syms from /usr/lib/x86_64-linux-gnu/libquadmath.so.0.0.0
--19667--   Considering /usr/lib/x86_64-linux-gnu/libquadmath.so.0.0.0 ..
--19667--   .. CRC mismatch (computed 43fdf4f9 wanted dd3358ca)
--19667--    object doesn't have a symbol table
--19667-- Reading syms from /lib/x86_64-linux-gnu/libm-2.23.so
--19667--   Considering /lib/x86_64-linux-gnu/libm-2.23.so ..
--19667--   .. CRC mismatch (computed 3989a391 wanted dd37ef77)
--19667--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.23.so ..
--19667--   .. CRC is valid
--19667-- Reading syms from /lib/x86_64-linux-gnu/libgcc_s.so.1
--19667--   Considering /lib/x86_64-linux-gnu/libgcc_s.so.1 ..
--19667--   .. CRC mismatch (computed 4fe824d1 wanted ed17a787)
--19667--    object doesn't have a symbol table
--19667-- REDIR: 0x51f9e50 (libc.so.6:strcasecmp) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51f56d0 (libc.so.6:strcspn) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51fc140 (libc.so.6:strncasecmp) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51f7b40 (libc.so.6:strpbrk) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51f7ed0 (libc.so.6:strspn) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51f959b (libc.so.6:memcpy@GLIBC_2.2.5) redirected to 0x4a286f0 (_vgnU_ifunc_wrapper)
--19667-- REDIR: 0x51f7850 (libc.so.6:rindex) redirected to 0x4c308a0 (rindex)
--19667-- REDIR: 0x51ef160 (libc.so.6:calloc) redirected to 0x4c2faa0 (calloc)
--19667-- REDIR: 0x51ee580 (libc.so.6:malloc) redirected to 0x4c2db20 (malloc)
--19667-- REDIR: 0x51fe8c0 (libc.so.6:__GI_memcpy) redirected to 0x4c32b00 (__GI_memcpy)
--19667-- REDIR: 0x51f5b70 (libc.so.6:strlen) redirected to 0x4c30f60 (strlen)
--19667-- REDIR: 0x51ee940 (libc.so.6:free) redirected to 0x4c2ed80 (free)
==19667==
==19667== HEAP SUMMARY:
==19667==     in use at exit: 4 bytes in 1 blocks
==19667==   total heap usage: 22 allocs, 21 frees, 28,228 bytes allocated
==19667==
==19667== Searching for pointers to 1 not-freed blocks
==19667== Checked 106,624 bytes
==19667==
==19667== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==19667==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==19667==    by 0x40080B: __static_intrinsic_type_m_MOD_add_static_intrinsic_type (leaks_raiser_static_intrinsic.f90:24)
==19667==    by 0x4008FC: MAIN__ (leaks_raiser_static_intrinsic.f90:37)
==19667==    by 0x40094E: main (leaks_raiser_static_intrinsic.f90:30)
==19667==
==19667== LEAK SUMMARY:
==19667==    definitely lost: 4 bytes in 1 blocks
==19667==    indirectly lost: 0 bytes in 0 blocks
==19667==      possibly lost: 0 bytes in 0 blocks
==19667==    still reachable: 0 bytes in 0 blocks
==19667==         suppressed: 0 bytes in 0 blocks
==19667==
==19667== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
--19667--
--19667-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==19667==
==19667== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
```

> This test generates leaks.

The code generated is

```c
add_static_intrinsic_type (struct __class_static_intrinsic_type_m_Static_intrinsic_type_t_t & restrict lhs, struct __class_static_intrinsic_type_m_Static_intrinsic_type_t_t & restrict rhs)
{
  struct __class_static_intrinsic_type_m_Static_intrinsic_type_t_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_static_intrinsic_type_m_Static_intrinsic_type_t *) res._vptr = &__vtab_static_intrinsic_type_m_Static_intrinsic_type_t;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 24 of file src/leaks_raiser_static_intrinsic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct static_intrinsic_type_t *) __builtin_malloc (4);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_static_intrinsic_type_m_Static_intrinsic_type_t *) res._vptr = &__vtab_static_intrinsic_type_m_Static_intrinsic_type_t;
      res._data->x = lhs->_data->x + rhs->_data->x;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}
```

---

##### static components derived

###### test code

```fortran
module static_derived_type_m
   implicit none
   type :: derived_t
      integer :: x
   endtype derived_t
   type :: static_derived_type_t
      type(derived_t) :: x
   contains
      generic :: assignment(=) => assign_static_derived_type
      generic :: operator(+) => add_static_derived_type
      procedure, pass(lhs) :: assign_static_derived_type
      procedure, pass(lhs) :: add_static_derived_type
   endtype static_derived_type_t
contains
   subroutine assign_static_derived_type(lhs, rhs)
      ! Operator `=`.
      class(static_derived_type_t), intent(inout) :: lhs
      class(static_derived_type_t), intent(in)    :: rhs
      lhs%x%x = rhs%x%x
   endsubroutine assign_static_derived_type

   function add_static_derived_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(static_derived_type_t), intent(in)  :: lhs
      class(static_derived_type_t), intent(in)  :: rhs
      class(static_derived_type_t), allocatable :: res
      allocate (static_derived_type_t :: res)
      res%x%x = lhs%x%x + rhs%x%x
   endfunction add_static_derived_type
endmodule static_derived_type_m
```

###### valgrind log

```
==20224== Memcheck, a memory error detector
==20224== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
...
==20224==
==20224== HEAP SUMMARY:
==20224==     in use at exit: 4 bytes in 1 blocks
==20224==   total heap usage: 22 allocs, 21 frees, 28,228 bytes allocated
==20224==
==20224== Searching for pointers to 1 not-freed blocks
==20224== Checked 106,624 bytes
==20224==
==20224== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==20224==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==20224==    by 0x40080B: __static_derived_type_m_MOD_add_static_derived_type (leaks_raiser_static_derived.f90:27)
==20224==    by 0x4008FC: MAIN__ (leaks_raiser_static_derived.f90:40)
==20224==    by 0x40094E: main (leaks_raiser_static_derived.f90:33)
==20224==
==20224== LEAK SUMMARY:
==20224==    definitely lost: 4 bytes in 1 blocks
==20224==    indirectly lost: 0 bytes in 0 blocks
==20224==      possibly lost: 0 bytes in 0 blocks
==20224==    still reachable: 0 bytes in 0 blocks
==20224==         suppressed: 0 bytes in 0 blocks
==20224==
==20224== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
--20224--
--20224-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==20224==
==20224== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
```

> This test generates leaks: the static nature seems to be cause as the previous one.

The code generated is

```c
add_static_derived_type (struct __class_static_derived_type_m_Static_derived_type_t_t & restrict lhs, struct __class_static_derived_type_m_Static_derived_type_t_t & restrict rhs)
{
  struct __class_static_derived_type_m_Static_derived_type_t_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_static_derived_type_m_Static_derived_type_t *) res._vptr = &__vtab_static_derived_type_m_Static_derived_type_t;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 27 of file src/leaks_raiser_static_derived.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct static_derived_type_t *) __builtin_malloc (4);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_static_derived_type_m_Static_derived_type_t *) res._vptr = &__vtab_static_derived_type_m_Static_derived_type_t;
      res._data->x.x = lhs->_data->x.x + rhs->_data->x.x;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}
```

---

##### dynamic components intrinsic

###### test code

```fortran
module dynamic_intrinsic_type_m
   implicit none
   type :: dynamic_intrinsic_type_t
      integer, allocatable :: x
   contains
      generic :: assignment(=) => assign_dynamic_intrinsic_type
      generic :: operator(+) => add_dynamic_intrinsic_type
      procedure, pass(lhs) :: assign_dynamic_intrinsic_type
      procedure, pass(lhs) :: add_dynamic_intrinsic_type
   endtype dynamic_intrinsic_type_t
contains
   subroutine assign_dynamic_intrinsic_type(lhs, rhs)
      ! Operator `=`.
      class(dynamic_intrinsic_type_t), intent(inout) :: lhs
      class(dynamic_intrinsic_type_t), intent(in)    :: rhs
      if (allocated(rhs%x)) then
        if (.not.allocated(lhs%x)) allocate(lhs%x)
        lhs%x = rhs%x
      endif
   endsubroutine assign_dynamic_intrinsic_type

   function add_dynamic_intrinsic_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(dynamic_intrinsic_type_t), intent(in)  :: lhs
      class(dynamic_intrinsic_type_t), intent(in)  :: rhs
      class(dynamic_intrinsic_type_t), allocatable :: res
      allocate (dynamic_intrinsic_type_t :: res)
      if (allocated(lhs%x).and.allocated(rhs%x)) then
        allocate(res%x)
        res%x = lhs%x + rhs%x
      endif
   endfunction add_dynamic_intrinsic_type
endmodule dynamic_intrinsic_type_m
```

###### valgrind log

```
==20559== Memcheck, a memory error detector
==20559== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==20559== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==20559== Command: a.out
...
==20559== HEAP SUMMARY:
==20559==     in use at exit: 8 bytes in 2 blocks
==20559==   total heap usage: 25 allocs, 23 frees, 28,244 bytes allocated
==20559==
==20559== Searching for pointers to 2 not-freed blocks
==20559== Checked 106,624 bytes
==20559==
==20559== 4 bytes in 1 blocks are still reachable in loss record 1 of 2
==20559==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==20559==    by 0x400EE8: MAIN__ (leaks_raiser_dynamic_intrinsic.f90:41)
==20559==    by 0x401039: main (leaks_raiser_dynamic_intrinsic.f90:36)
==20559==
==20559== 4 bytes in 1 blocks are still reachable in loss record 2 of 2
==20559==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==20559==    by 0x400E3B: __dynamic_intrinsic_type_m_MOD_assign_dynamic_intrinsic_type (leaks_raiser_dynamic_intrinsic.f90:17)
==20559==    by 0x400F62: MAIN__ (leaks_raiser_dynamic_intrinsic.f90:43)
==20559==    by 0x401039: main (leaks_raiser_dynamic_intrinsic.f90:36)
==20559==
==20559== LEAK SUMMARY:
==20559==    definitely lost: 0 bytes in 0 blocks
==20559==    indirectly lost: 0 bytes in 0 blocks
==20559==      possibly lost: 0 bytes in 0 blocks
==20559==    still reachable: 8 bytes in 2 blocks
==20559==         suppressed: 0 bytes in 0 blocks
==20559==
==20559== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
--20559--
--20559-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==20559==
==20559== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
```

> This test does **NOT** generates leaks. The cause seems to be the allocatable nature of the component.

The code generates is

```c
add_dynamic_intrinsic_type (struct __class_5553406_t & restrict lhs, struct __class_5553406_t & restrict rhs)
{
  struct __class_5553406_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_5553406 *) res._vptr = &__vtab_5553406;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 27 of file src/leaks_raiser_dynamic_intrinsic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct dynamic_intrinsic_type_t *) __builtin_malloc (8);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_5553406 *) res._vptr = &__vtab_5553406;
      (void) __builtin_memcpy ((void *) res._data, (void *) res._vptr->_def_init, (unsigned long) res._vptr->_size);
      if (lhs->_data->x != 0B && rhs->_data->x != 0B)
        {
          if (res._data->x != 0B)
            {
              _gfortran_runtime_error_at (&"At line 29 of file src/leaks_raiser_dynamic_intrinsic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
            }
          else
            {
              res._data->x = (integer(kind=4) *) __builtin_malloc (4);
              if (res._data->x == 0B)
                {
                  _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                }
            }
          if (res._data->x != 0B) goto L.12;
          res._data->x = (integer(kind=4) *) __builtin_malloc (4);
          L.12:;
          *res._data->x = *lhs->_data->x + *rhs->_data->x;
        }
      L.11:;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}

```

---

##### dynamic components derived

###### test code

```fortran
module dynamic_derived_type_m
   implicit none
   type :: derived_t
      integer :: x
   endtype derived_t
   type :: dynamic_derived_type_t
      type(derived_t), allocatable :: x
   contains
      generic :: assignment(=) => assign_dynamic_derived_type
      generic :: operator(+) => add_dynamic_derived_type
      procedure, pass(lhs) :: assign_dynamic_derived_type
      procedure, pass(lhs) :: add_dynamic_derived_type
   endtype dynamic_derived_type_t
contains
   subroutine assign_dynamic_derived_type(lhs, rhs)
      ! Operator `=`.
      class(dynamic_derived_type_t), intent(inout) :: lhs
      class(dynamic_derived_type_t), intent(in)    :: rhs
      if (allocated(rhs%x)) then
        if (.not.allocated(lhs%x)) allocate(lhs%x)
        lhs%x%x = rhs%x%x
      endif
   endsubroutine assign_dynamic_derived_type

   function add_dynamic_derived_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(dynamic_derived_type_t), intent(in)  :: lhs
      class(dynamic_derived_type_t), intent(in)  :: rhs
      class(dynamic_derived_type_t), allocatable :: res
      allocate (dynamic_derived_type_t :: res)
      if (allocated(lhs%x).and.allocated(rhs%x)) then
        allocate(res%x)
        res%x%x = lhs%x%x + rhs%x%x
      endif
   endfunction add_dynamic_derived_type
endmodule dynamic_derived_type_m
```

###### valgrind log

```
==20836== Memcheck, a memory error detector
==20836== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==20836== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==20836== Command: a.out
...
==20836== HEAP SUMMARY:
==20836==     in use at exit: 8 bytes in 2 blocks
==20836==   total heap usage: 25 allocs, 23 frees, 28,244 bytes allocated
==20836==
==20836== Searching for pointers to 2 not-freed blocks
==20836== Checked 106,624 bytes
==20836==
==20836== 4 bytes in 1 blocks are still reachable in loss record 1 of 2
==20836==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==20836==    by 0x400E9C: MAIN__ (leaks_raiser_dynamic_derived.f90:44)
==20836==    by 0x400FD0: main (leaks_raiser_dynamic_derived.f90:39)
==20836==
==20836== 4 bytes in 1 blocks are still reachable in loss record 2 of 2
==20836==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==20836==    by 0x400E12: __dynamic_derived_type_m_MOD_assign_dynamic_derived_type (leaks_raiser_dynamic_derived.f90:20)
==20836==    by 0x400EF9: MAIN__ (leaks_raiser_dynamic_derived.f90:46)
==20836==    by 0x400FD0: main (leaks_raiser_dynamic_derived.f90:39)
==20836==
==20836== LEAK SUMMARY:
==20836==    definitely lost: 0 bytes in 0 blocks
==20836==    indirectly lost: 0 bytes in 0 blocks
==20836==      possibly lost: 0 bytes in 0 blocks
==20836==    still reachable: 8 bytes in 2 blocks
==20836==         suppressed: 0 bytes in 0 blocks
==20836==
==20836== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
--20836--
--20836-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==20836==
==20836== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
```

> This test does **NOT** generates leaks. The cause seems to be the allocatable nature of the component.

The code generates is

```c
add_dynamic_derived_type (struct __class_dynamic_derived_type_m_Dynamic_derived_type_t_t & restrict lhs, struct __class_dynamic_derived_type_m_Dynamic_derived_type_t_t & restrict rhs)
{
  struct __class_dynamic_derived_type_m_Dynamic_derived_type_t_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_dynamic_derived_type_m_Dynamic_derived_type_t *) res._vptr = &__vtab_dynamic_derived_type_m_Dynamic_derived_type_t;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 30 of file src/leaks_raiser_dynamic_derived.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct dynamic_derived_type_t *) __builtin_malloc (8);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_dynamic_derived_type_m_Dynamic_derived_type_t *) res._vptr = &__vtab_dynamic_derived_type_m_Dynamic_derived_type_t;
      (void) __builtin_memcpy ((void *) res._data, (void *) res._vptr->_def_init, (unsigned long) res._vptr->_size);
      if (lhs->_data->x != 0B && rhs->_data->x != 0B)
        {
          if (res._data->x != 0B)
            {
              _gfortran_runtime_error_at (&"At line 32 of file src/leaks_raiser_dynamic_derived.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
            }
          else
            {
              res._data->x = (struct derived_t *) __builtin_malloc (4);
              if (res._data->x == 0B)
                {
                  _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                }
            }
          res._data->x->x = lhs->_data->x->x + rhs->_data->x->x;
        }
      L.11:;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}

```

---

##### polymorphic components

###### test code

```fortran
module polymorphic_type_m
   implicit none
   type :: derived_t
      integer :: x
   endtype derived_t
   type :: polymorphic_type_t
      class(derived_t), allocatable :: x
   contains
      generic :: assignment(=) => assign_polymorphic_type
      generic :: operator(+) => add_polymorphic_type
      procedure, pass(lhs) :: assign_polymorphic_type
      procedure, pass(lhs) :: add_polymorphic_type
   endtype polymorphic_type_t
contains
   subroutine assign_polymorphic_type(lhs, rhs)
      ! Operator `=`.
      class(polymorphic_type_t), intent(inout) :: lhs
      class(polymorphic_type_t), intent(in)    :: rhs
      if (allocated(rhs%x)) then
         if (.not.allocated(lhs%x)) allocate(derived_t :: lhs%x)
         select type(lhsx => lhs%x)
         type is(derived_t)
            select type(rhsx => rhs%x)
            type is(derived_t)
               lhsx%x = rhsx%x
            endselect
         endselect
      endif
   endsubroutine assign_polymorphic_type

   function add_polymorphic_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(polymorphic_type_t), intent(in)  :: lhs
      class(polymorphic_type_t), intent(in)  :: rhs
      class(polymorphic_type_t), allocatable :: res
      allocate (polymorphic_type_t :: res)
      if (allocated(lhs%x).and.allocated(rhs%x)) then
         allocate(derived_t :: res%x)
         select type(lhsx => lhs%x)
         type is(derived_t)
            select type(rhsx => rhs%x)
            type is(derived_t)
               select type(resx => res%x)
               type is(derived_t)
                  resx%x = lhsx%x + rhsx%x
               endselect
            endselect
         endselect
      endif
   endfunction add_polymorphic_type
endmodule polymorphic_type_m
```

###### valgrind log

```
==21088== Memcheck, a memory error detector
==21088== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==21088== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==21088== Command: a.out
...
==21088== HEAP SUMMARY:
==21088==     in use at exit: 8 bytes in 2 blocks
==21088==   total heap usage: 25 allocs, 23 frees, 28,252 bytes allocated
==21088==
==21088== Searching for pointers to 2 not-freed blocks
==21088== Checked 106,624 bytes
==21088==
==21088== 4 bytes in 1 blocks are still reachable in loss record 1 of 2
==21088==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21088==    by 0x401017: MAIN__ (leaks_raiser_polymorphic.f90:59)
==21088==    by 0x4011E6: main (leaks_raiser_polymorphic.f90:54)
==21088==
==21088== 4 bytes in 1 blocks are still reachable in loss record 2 of 2
==21088==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21088==    by 0x400F33: __polymorphic_type_m_MOD_assign_polymorphic_type (leaks_raiser_polymorphic.f90:20)
==21088==    by 0x4010A1: MAIN__ (leaks_raiser_polymorphic.f90:64)
==21088==    by 0x4011E6: main (leaks_raiser_polymorphic.f90:54)
==21088==
==21088== LEAK SUMMARY:
==21088==    definitely lost: 0 bytes in 0 blocks
==21088==    indirectly lost: 0 bytes in 0 blocks
==21088==      possibly lost: 0 bytes in 0 blocks
==21088==    still reachable: 8 bytes in 2 blocks
==21088==         suppressed: 0 bytes in 0 blocks
==21088==
==21088== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
--21088--
--21088-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==21088==
==21088== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
```

> This test does **NOT** generates leaks. The cause seems to be the allocatable nature of the component.

The code generates is

```c
add_polymorphic_type (struct __class_polymorphic_type_m_Polymorphic_type_t_t & restrict lhs, struct __class_polymorphic_type_m_Polymorphic_type_t_t & restrict rhs)
{
  struct __class_polymorphic_type_m_Polymorphic_type_t_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_polymorphic_type_m_Polymorphic_type_t *) res._vptr = &__vtab_polymorphic_type_m_Polymorphic_type_t;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 36 of file src/leaks_raiser_polymorphic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct polymorphic_type_t *) __builtin_malloc (16);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_polymorphic_type_m_Polymorphic_type_t *) res._vptr = &__vtab_polymorphic_type_m_Polymorphic_type_t;
      (void) __builtin_memcpy ((void *) res._data, (void *) res._vptr->_def_init, (unsigned long) res._vptr->_size);
      if (lhs->_data->x._data != 0B && rhs->_data->x._data != 0B)
        {
          {
            struct derived_t * __tmp_type_derived_t;
            struct __class_polymorphic_type_m_Derived_t_p * lhsx;

            if (res._data->x._data != 0B)
              {
                _gfortran_runtime_error_at (&"At line 38 of file src/leaks_raiser_polymorphic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
              }
            else
              {
                res._data->x._data = (struct derived_t *) __builtin_malloc (4);
                if (res._data->x._data == 0B)
                  {
                    _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                  }
              }
            (struct __vtype_polymorphic_type_m_Derived_t *) res._data->x._vptr = &__vtab_polymorphic_type_m_Derived_t;
            lhsx = (struct __class_polymorphic_type_m_Derived_t_p *) &lhs->_data->x;
            switch (lhsx->_vptr->_hash)
              {
                case 94425380:;
                __tmp_type_derived_t = lhsx->_data;
                {
                  struct derived_t * __tmp_type_derived_t;
                  struct __class_polymorphic_type_m_Derived_t_p * rhsx;

                  rhsx = (struct __class_polymorphic_type_m_Derived_t_p *) &rhs->_data->x;
                  switch (rhsx->_vptr->_hash)
                    {
                      case 94425380:;
                      __tmp_type_derived_t = rhsx->_data;
                      {
                        struct derived_t * __tmp_type_derived_t;
                        struct __class_polymorphic_type_m_Derived_t_p * resx;

                        resx = (struct __class_polymorphic_type_m_Derived_t_p *) &res._data->x;
                        switch (resx->_vptr->_hash)
                          {
                            case 94425380:;
                            __tmp_type_derived_t = resx->_data;
                            __tmp_type_derived_t->x = __tmp_type_derived_t->x + __tmp_type_derived_t->x;
                            L.26:;
                            goto L.24;
                          }
                        L.24:;
                        L.23:;
                        L.22:;
                      }
                      L.21:;
                      goto L.19;
                    }
                  L.19:;
                  L.18:;
                  L.17:;
                }
                L.16:;
                goto L.14;
              }
            L.14:;
            L.13:;
            L.12:;
          }
        }
      L.11:;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}
```

---

##### complex inheritance

###### test code

```fortran
module inherit_type_m
   implicit none
   type :: derived_t
      integer :: x
   contains
      generic :: assignment(=) => assign_derived_type
      generic :: operator(+) => add_derived_type
      procedure, pass(lhs) :: assign_derived_type
      procedure, pass(lhs) :: add_derived_type
   endtype derived_t

   type :: inherit_type_t
      type(derived_t), allocatable :: x
   contains
      generic :: assignment(=) => assign_inherit_type
      generic :: operator(+) => add_inherit_type
      procedure, pass(lhs) :: assign_inherit_type
      procedure, pass(lhs) :: add_inherit_type
   endtype inherit_type_t
contains
   subroutine assign_derived_type(lhs, rhs)
      ! Operator `=`.
      class(derived_t), intent(inout) :: lhs
      class(derived_t), intent(in)    :: rhs
      lhs%x = rhs%x
   endsubroutine assign_derived_type

   function add_derived_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(derived_t), intent(in)  :: lhs
      class(derived_t), intent(in)  :: rhs
      class(derived_t), allocatable :: res
      allocate (derived_t :: res)
      res%x = lhs%x + rhs%x
   endfunction add_derived_type

   subroutine assign_inherit_type(lhs, rhs)
      ! Operator `=`.
      class(inherit_type_t), intent(inout) :: lhs
      class(inherit_type_t), intent(in)    :: rhs
      if (allocated(rhs%x)) then
        if (.not.allocated(lhs%x)) allocate(lhs%x)
        lhs%x = rhs%x
      endif
   endsubroutine assign_inherit_type

   function add_inherit_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(inherit_type_t), intent(in)  :: lhs
      class(inherit_type_t), intent(in)  :: rhs
      class(inherit_type_t), allocatable :: res
      allocate (inherit_type_t :: res)
      if (allocated(lhs%x).and.allocated(rhs%x)) then
        allocate(res%x)
        res%x = lhs%x + rhs%x
      endif
   endfunction add_inherit_type
endmodule inherit_type_m
```

###### valgrind log

```
==21341== Memcheck, a memory error detector
==21341== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==21341== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==21341== Command: a.out
...
==21341== HEAP SUMMARY:
==21341==     in use at exit: 12 bytes in 3 blocks
==21341==   total heap usage: 26 allocs, 23 frees, 28,248 bytes allocated
==21341==
==21341== Searching for pointers to 3 not-freed blocks
==21341== Checked 106,624 bytes
==21341==
==21341== 4 bytes in 1 blocks are still reachable in loss record 1 of 3
==21341==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21341==    by 0x400FEE: MAIN__ (leaks_raiser_complex_inheritance.f90:66)
==21341==    by 0x401168: main (leaks_raiser_complex_inheritance.f90:61)
==21341==
==21341== 4 bytes in 1 blocks are still reachable in loss record 2 of 3
==21341==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21341==    by 0x400E82: __inherit_type_m_MOD_assign_inherit_type (leaks_raiser_complex_inheritance.f90:42)
==21341==    by 0x40107C: MAIN__ (leaks_raiser_complex_inheritance.f90:68)
==21341==    by 0x401168: main (leaks_raiser_complex_inheritance.f90:61)
==21341==
==21341== 4 bytes in 1 blocks are definitely lost in loss record 3 of 3
==21341==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21341==    by 0x400F31: __inherit_type_m_MOD_add_derived_type (leaks_raiser_complex_inheritance.f90:33)
==21341==    by 0x400DE4: __inherit_type_m_MOD_add_inherit_type (leaks_raiser_complex_inheritance.f90:55)
==21341==    by 0x4010D1: MAIN__ (leaks_raiser_complex_inheritance.f90:69)
==21341==    by 0x401168: main (leaks_raiser_complex_inheritance.f90:61)
==21341==
==21341== LEAK SUMMARY:
==21341==    definitely lost: 4 bytes in 1 blocks
==21341==    indirectly lost: 0 bytes in 0 blocks
==21341==      possibly lost: 0 bytes in 0 blocks
==21341==    still reachable: 8 bytes in 2 blocks
==21341==         suppressed: 0 bytes in 0 blocks
==21341==
==21341== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
--21341--
--21341-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==21341==
==21341== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 1 from 1)
```

> This test **generates** leaks, probably due to the static component of the inherited type.

The code generates is

```c
add_inherit_type (struct __class_inherit_type_m_Inherit_type_t_t & restrict lhs, struct __class_inherit_type_m_Inherit_type_t_t & restrict rhs)
{
  struct __class_inherit_type_m_Inherit_type_t_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_inherit_type_m_Inherit_type_t *) res._vptr = &__vtab_inherit_type_m_Inherit_type_t;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 52 of file src/leaks_raiser_complex_inheritance.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct inherit_type_t *) __builtin_malloc (8);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_inherit_type_m_Inherit_type_t *) res._vptr = &__vtab_inherit_type_m_Inherit_type_t;
      (void) __builtin_memcpy ((void *) res._data, (void *) res._vptr->_def_init, (unsigned long) res._vptr->_size);
      if (lhs->_data->x != 0B && rhs->_data->x != 0B)
        {
          if (res._data->x != 0B)
            {
              _gfortran_runtime_error_at (&"At line 54 of file src/leaks_raiser_complex_inheritance.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
            }
          else
            {
              res._data->x = (struct derived_t *) __builtin_malloc (4);
              if (res._data->x == 0B)
                {
                  _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                }
            }
          {
            struct __class_inherit_type_m_Derived_t_t class.6;
            struct __class_inherit_type_m_Derived_t_t rhs.7;
            struct __class_inherit_type_m_Derived_t_t class.8;
            struct __class_inherit_type_m_Derived_t_t class.9;

            class.6._vptr = (struct __vtype_inherit_type_m_Derived_t * {ref-all}) &__vtab_inherit_type_m_Derived_t;
            class.6._data = res._data->x;
            class.8._vptr = (struct __vtype_inherit_type_m_Derived_t * {ref-all}) &__vtab_inherit_type_m_Derived_t;
            class.8._data = lhs->_data->x;
            class.9._vptr = (struct __vtype_inherit_type_m_Derived_t * {ref-all}) &__vtab_inherit_type_m_Derived_t;
            class.9._data = rhs->_data->x;
            rhs.7 = VIEW_CONVERT_EXPR<struct __class_inherit_type_m_Derived_t_t>(add_derived_type (&class.8, &class.9));
            assign_derived_type (&class.6, &rhs.7);
          }
        }
      L.11:;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}
```

---

### workaround

It seems that inserting an allocatable component along side the static ones trigger a correct freeing of temporaries thus the memory leaks generation vanishes, e.g.

```fortran
module static_dynamic_intrinsic_type_m
   implicit none
   type :: static_dynamic_intrinsic_type_t
      integer              :: x
      integer, allocatable :: y
   contains
      generic :: assignment(=) => assign_static_dynamic_intrinsic_type
      generic :: operator(+) => add_static_dynamic_intrinsic_type
      procedure, pass(lhs) :: assign_static_dynamic_intrinsic_type
      procedure, pass(lhs) :: add_static_dynamic_intrinsic_type
   endtype static_dynamic_intrinsic_type_t
contains
   subroutine assign_static_dynamic_intrinsic_type(lhs, rhs)
      ! Operator `=`.
      class(static_dynamic_intrinsic_type_t), intent(inout) :: lhs
      class(static_dynamic_intrinsic_type_t), intent(in)    :: rhs
      lhs%x = rhs%x
      if (allocated(rhs%y)) then
         if (.not.allocated(lhs%y)) allocate(lhs%y)
         lhs%y = rhs%y
      endif
   endsubroutine assign_static_dynamic_intrinsic_type

   function add_static_dynamic_intrinsic_type(lhs, rhs) result(res)
      ! Operator `+`.
      class(static_dynamic_intrinsic_type_t), intent(in)  :: lhs
      class(static_dynamic_intrinsic_type_t), intent(in)  :: rhs
      class(static_dynamic_intrinsic_type_t), allocatable :: res
      allocate (static_dynamic_intrinsic_type_t :: res)
      res%x = lhs%x + rhs%x
      if (allocated(lhs%y).and.allocated(rhs%y)) then
         allocate(res%y)
         res%y = lhs%y + rhs%y
      endif
   endfunction add_static_dynamic_intrinsic_type
endmodule static_dynamic_intrinsic_type_m
```

###### valgrind log

```
==21841== Memcheck, a memory error detector
==21841== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==21841== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==21841== Command: a.out
...
==21841== HEAP SUMMARY:
==21841==     in use at exit: 8 bytes in 2 blocks
==21841==   total heap usage: 25 allocs, 23 frees, 28,252 bytes allocated
==21841==
==21841== Searching for pointers to 2 not-freed blocks
==21841== Checked 106,624 bytes
==21841==
==21841== 4 bytes in 1 blocks are still reachable in loss record 1 of 2
==21841==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21841==    by 0x400F41: MAIN__ (leaks_raiser_static_dynamic_intrinsic.f90:45)
==21841==    by 0x401095: main (leaks_raiser_static_dynamic_intrinsic.f90:39)
==21841==
==21841== 4 bytes in 1 blocks are still reachable in loss record 2 of 2
==21841==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==21841==    by 0x400E84: __static_dynamic_intrinsic_type_m_MOD_assign_static_dynamic_intrinsic_type (leaks_raiser_static_dynamic_intrinsic.f90:19)
==21841==    by 0x400FBB: MAIN__ (leaks_raiser_static_dynamic_intrinsic.f90:47)
==21841==    by 0x401095: main (leaks_raiser_static_dynamic_intrinsic.f90:39)
==21841==
==21841== LEAK SUMMARY:
==21841==    definitely lost: 0 bytes in 0 blocks
==21841==    indirectly lost: 0 bytes in 0 blocks
==21841==      possibly lost: 0 bytes in 0 blocks
==21841==    still reachable: 8 bytes in 2 blocks
==21841==         suppressed: 0 bytes in 0 blocks
==21841==
==21841== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
--21841--
--21841-- used_suppression:      1 dl-hack3-cond-1 /usr/lib/valgrind/default.supp:1218
==21841==
==21841== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
```

> The bytes lost are **zero**, however there seem to be 8 bytes *still reachable* that should be a sort of false positive.

The generated code is

```c
add_static_dynamic_intrinsic_type (struct __class_43B76E_t & restrict lhs, struct __class_43B76E_t & restrict rhs)
{
  struct __class_43B76E_a res;

  try
    {
      res._data = 0B;
      (struct __vtype_43B76E *) res._vptr = &__vtab_43B76E;
      if (res._data != 0B)
        {
          _gfortran_runtime_error_at (&"At line 29 of file src/leaks_raiser_static_dynamic_intrinsic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
        }
      else
        {
          res._data = (struct static_dynamic_intrinsic_type_t *) __builtin_malloc (16);
          if (res._data == 0B)
            {
              _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
            }
        }
      (struct __vtype_43B76E *) res._vptr = &__vtab_43B76E;
      (void) __builtin_memcpy ((void *) res._data, (void *) res._vptr->_def_init, (unsigned long) res._vptr->_size);
      res._data->x = lhs->_data->x + rhs->_data->x;
      if (lhs->_data->y != 0B && rhs->_data->y != 0B)
        {
          if (res._data->y != 0B)
            {
              _gfortran_runtime_error_at (&"At line 32 of file src/leaks_raiser_static_dynamic_intrinsic.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"res"[1]{lb: 1 sz: 1});
            }
          else
            {
              res._data->y = (integer(kind=4) *) __builtin_malloc (4);
              if (res._data->y == 0B)
                {
                  _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                }
            }
          if (res._data->y != 0B) goto L.12;
          res._data->y = (integer(kind=4) *) __builtin_malloc (4);
          L.12:;
          *res._data->y = *lhs->_data->y + *rhs->_data->y;
        }
      L.11:;
      return res;
    }
  finally
    {
      res._data = 0B;
    }
}

```

---

### multiple inheritance

#### the failing of workaround

It seems that there is at least one scenario where the workaround does not work:

```fortran
module ancestor_m
implicit none

type, abstract :: ancestor_t
   integer, allocatable :: workaround
   contains
      generic :: assignment(=) => assign_
      generic :: operator(+) => add_
      procedure(assign_interface), pass(lhs), deferred :: assign_
      procedure(add_interface),    pass(lhs), deferred :: add_
endtype ancestor_t

abstract interface
   subroutine assign_interface(lhs, rhs)
   ! Operator `=`.
   import :: ancestor_t
   class(ancestor_t), intent(inout) :: lhs
   class(ancestor_t), intent(in)    :: rhs
   endsubroutine assign_interface

   function add_interface(lhs, rhs) result(opr)
   ! Operator `+`.
   import :: ancestor_t
   class(ancestor_t), intent(in)  :: lhs
   class(ancestor_t), intent(in)  :: rhs
   class(ancestor_t), allocatable :: opr
   endfunction add_interface
endinterface
endmodule ancestor_m

module parent_m
use ancestor_m
implicit none

type, extends(ancestor_t), abstract :: parent_t
endtype parent_t
endmodule parent_m

module child_m
use ancestor_m
use parent_m
implicit none

type, extends(parent_t) :: child_t
   integer              :: x
   integer, allocatable :: y
   contains
      procedure, pass(lhs) :: assign_
      procedure, pass(lhs) :: add_
endtype child_t

contains
   subroutine assign_(lhs, rhs)
   ! Operator `=`.
   class(child_t),    intent(inout) :: lhs
   class(ancestor_t), intent(in)    :: rhs

   select type(rhs)
   class is(child_t)
      lhs%x = rhs%x
      if (allocated(rhs%y)) then
        if (.not.allocated(lhs%y)) allocate(lhs%y)
        lhs%y = rhs%y
      endif
   endselect
   endsubroutine assign_

   function add_(lhs, rhs) result(opr)
   ! Operator `+`.
   class(child_t),    intent(in)  :: lhs
   class(ancestor_t), intent(in)  :: rhs
   class(ancestor_t), allocatable :: opr

   allocate(child_t :: opr)
   select type(opr)
   class is(child_t)
      select type(rhs)
      class is(child_t)
         opr%x = lhs%x + rhs%x
         if (allocated(lhs%y).and.allocated(rhs%y)) then
           allocate(opr%y)
           opr%y = lhs%y + rhs%y
         endif
      endselect
   endselect
   endfunction add_
endmodule child_m
```

###### valgrind log

```
==57470== Memcheck, a memory error detector
==57470== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==57470== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==57470== Command: a.out
...
==57470== HEAP SUMMARY:
==57470==     in use at exit: 12 bytes in 3 blocks
==57470==   total heap usage: 25 allocs, 22 frees, 28,260 bytes allocated
==57470==
==57470== Searching for pointers to 3 not-freed blocks
==57470== Checked 89,008 bytes
==57470==
==57470== 4 bytes in 1 blocks are still reachable in loss record 1 of 3
==57470==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==57470==    by 0x401752: MAIN__ (leaks_raiser_multiple_inheritance.f90:95)
==57470==    by 0x4018AD: main (leaks_raiser_multiple_inheritance.f90:90)
==57470==
==57470== 4 bytes in 1 blocks are still reachable in loss record 2 of 3
==57470==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==57470==    by 0x401688: __child_m_MOD_assign_ (leaks_raiser_multiple_inheritance.f90:62)
==57470==    by 0x4017D6: MAIN__ (leaks_raiser_multiple_inheritance.f90:98)
==57470==    by 0x4018AD: main (leaks_raiser_multiple_inheritance.f90:90)
==57470==
==57470== 4 bytes in 1 blocks are definitely lost in loss record 3 of 3
==57470==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==57470==    by 0x401573: __child_m_MOD_add_ (leaks_raiser_multiple_inheritance.f90:81)
==57470==    by 0x401819: MAIN__ (leaks_raiser_multiple_inheritance.f90:99)
==57470==    by 0x4018AD: main (leaks_raiser_multiple_inheritance.f90:90)
==57470==
==57470== LEAK SUMMARY:
==57470==    definitely lost: 4 bytes in 1 blocks
==57470==    indirectly lost: 0 bytes in 0 blocks
==57470==      possibly lost: 0 bytes in 0 blocks
==57470==    still reachable: 8 bytes in 2 blocks
==57470==         suppressed: 0 bytes in 0 blocks
==57470==
==57470== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==57470== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

> There is a memory leak.

The generated code is

```c
add_ (struct __class_child_m_Child_t_t & restrict lhs, struct __class_ancestor_m_Ancestor_t_t & restrict rhs)
{
  struct __class_ancestor_m_Ancestor_t_a opr;

  try
    {
      opr._data = 0B;
      (struct __vtype_ancestor_m_Ancestor_t *) opr._vptr = &__vtab_ancestor_m_Ancestor_t;
      {
        struct __class_child_m_Child_t_t * __tmp_class_child_t;

        if (opr._data != 0B)
          {
            _gfortran_runtime_error_at (&"At line 74 of file src/leaks_raiser_multiple_inheritance.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"opr"[1]{lb: 1 sz: 1});
          }
        else
          {
            opr._data = (struct ancestor_t *) __builtin_malloc (24);
            if (opr._data == 0B)
              {
                _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
              }
          }
        (struct __vtype_ancestor_m_Ancestor_t *) opr._vptr = (struct __vtype_ancestor_m_Ancestor_t *) &__vtab_child_m_Child_t;
        (void) __builtin_memcpy ((void *) opr._data, (void *) opr._vptr->_def_init, (unsigned long) opr._vptr->_size);
        switch (opr._vptr->_hash)
          {
            default:;
            if (_gfortran_is_extension_of ((struct __vtype_ancestor_m_Ancestor_t *) opr._vptr, &__vtab_child_m_Child_t))
              {
                __tmp_class_child_t = (struct __class_child_m_Child_t_t *) &opr;
                {
                  struct __class_child_m_Child_t_t * __tmp_class_child_t;

                  switch (rhs->_vptr->_hash)
                    {
                      default:;
                      if (_gfortran_is_extension_of ((struct __vtype_ancestor_m_Ancestor_t *) rhs->_vptr, &__vtab_child_m_Child_t))
                        {
                          __tmp_class_child_t = (struct __class_child_m_Child_t_t *) rhs;
                          __tmp_class_child_t->_data->x = lhs->_data->x + __tmp_class_child_t->_data->x;
                          if (lhs->_data->y != 0B && __tmp_class_child_t->_data->y != 0B)
                            {
                              if (__tmp_class_child_t->_data->y != 0B)
                                {
                                  _gfortran_runtime_error_at (&"At line 81 of file src/leaks_raiser_multiple_inheritance.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"__tmp_class_child_t"[1]{lb: 1 sz: 1});
                                }
                              else
                                {
                                  __tmp_class_child_t->_data->y = (integer(kind=4) *) __builtin_malloc (4);
                                  if (__tmp_class_child_t->_data->y == 0B)
                                    {
                                      _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                                    }
                                }
                              if (__tmp_class_child_t->_data->y != 0B) goto L.47;
                              __tmp_class_child_t->_data->y = (integer(kind=4) *) __builtin_malloc (4);
                              L.47:;
                              *__tmp_class_child_t->_data->y = *lhs->_data->y + *__tmp_class_child_t->_data->y;
                            }
                          L.46:;
                          L.45:;
                        }
                      L.44:;
                      goto L.42;
                    }
                  L.42:;
                  L.41:;
                  L.40:;
                }
                L.39:;
              }
            L.38:;
            goto L.36;
          }
        L.36:;
        L.35:;
        L.34:;
      }
      return opr;
    }
  finally
    {
      opr._data = 0B;
    }
}
```

The failing test can be even reduced trimming out abstracts and to one level of inheritance:

```fortran
module parent_m
implicit none

type :: parent_t
   integer, allocatable :: workaround
endtype parent_t
endmodule parent_m

module child_m
use parent_m
implicit none

type, extends(parent_t) :: child_t
   integer              :: x
   integer, allocatable :: y
   contains
      generic :: assignment(=) => assign_
      generic :: operator(+) => add_
      procedure, pass(lhs) :: assign_
      procedure, pass(lhs) :: add_
endtype child_t

contains
   subroutine assign_(lhs, rhs)
   ! Operator `=`.
   class(child_t),  intent(inout) :: lhs
   class(parent_t), intent(in)    :: rhs

   select type(rhs)
   class is(child_t)
      lhs%x = rhs%x
      if (allocated(rhs%y)) then
        if (.not.allocated(lhs%y)) allocate(lhs%y)
        lhs%y = rhs%y
      endif
   endselect
   endsubroutine assign_

   function add_(lhs, rhs) result(opr)
   ! Operator `+`.
   class(child_t),  intent(in)  :: lhs
   class(parent_t), intent(in)  :: rhs
   class(parent_t), allocatable :: opr

   allocate(child_t :: opr)
   select type(opr)
   class is(child_t)
      select type(rhs)
      class is(child_t)
         opr%x = lhs%x + rhs%x
         if (allocated(lhs%y).and.allocated(rhs%y)) then
           allocate(opr%y)
           opr%y = lhs%y + rhs%y
         endif
      endselect
   endselect
   endfunction add_
endmodule child_m
```

###### valgrind log

```
==5050== Memcheck, a memory error detector
==5050== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==5050== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==5050== Command: a.out
...
==5050== HEAP SUMMARY:
==5050==     in use at exit: 12 bytes in 3 blocks
==5050==   total heap usage: 25 allocs, 22 frees, 28,260 bytes allocated
==5050==
==5050== Searching for pointers to 3 not-freed blocks
==5050== Checked 89,008 bytes
==5050==
==5050== 4 bytes in 1 blocks are still reachable in loss record 1 of 3
==5050==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==5050==    by 0x4013D4: MAIN__ (leaks_raiser_multiple_inheritance_simple.f90:66)
==5050==    by 0x40152F: main (leaks_raiser_multiple_inheritance_simple.f90:61)
==5050==
==5050== 4 bytes in 1 blocks are still reachable in loss record 2 of 3
==5050==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==5050==    by 0x40130A: __child_m_MOD_assign_ (leaks_raiser_multiple_inheritance_simple.f90:33)
==5050==    by 0x401458: MAIN__ (leaks_raiser_multiple_inheritance_simple.f90:69)
==5050==    by 0x40152F: main (leaks_raiser_multiple_inheritance_simple.f90:61)
==5050==
==5050== 4 bytes in 1 blocks are definitely lost in loss record 3 of 3
==5050==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==5050==    by 0x4011F5: __child_m_MOD_add_ (leaks_raiser_multiple_inheritance_simple.f90:52)
==5050==    by 0x40149B: MAIN__ (leaks_raiser_multiple_inheritance_simple.f90:70)
==5050==    by 0x40152F: main (leaks_raiser_multiple_inheritance_simple.f90:61)
==5050==
==5050== LEAK SUMMARY:
==5050==    definitely lost: 4 bytes in 1 blocks
==5050==    indirectly lost: 0 bytes in 0 blocks
==5050==      possibly lost: 0 bytes in 0 blocks
==5050==    still reachable: 8 bytes in 2 blocks
==5050==         suppressed: 0 bytes in 0 blocks
==5050==
==5050== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==5050== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

> The leaks are the same of above: the allocatable `child_t%y` generates leaks.

The generated code is

```c
add_ (struct __class_child_m_Child_t_t & restrict lhs, struct __class_parent_m_Parent_t_t & restrict rhs)
{
  struct __class_parent_m_Parent_t_a opr;

  try
    {
      opr._data = 0B;
      (struct __vtype_parent_m_Parent_t *) opr._vptr = &__vtab_parent_m_Parent_t;
      {
        struct __class_child_m_Child_t_t * __tmp_class_child_t;

        if (opr._data != 0B)
          {
            _gfortran_runtime_error_at (&"At line 45 of file src/leaks_raiser_multiple_inheritance_simple.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"opr"[1]{lb: 1 sz: 1});
          }
        else
          {
            opr._data = (struct parent_t *) __builtin_malloc (24);
            if (opr._data == 0B)
              {
                _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
              }
          }
        (struct __vtype_parent_m_Parent_t *) opr._vptr = (struct __vtype_parent_m_Parent_t *) &__vtab_child_m_Child_t;
        (void) __builtin_memcpy ((void *) opr._data, (void *) opr._vptr->_def_init, (unsigned long) opr._vptr->_size);
        switch (opr._vptr->_hash)
          {
            default:;
            if (_gfortran_is_extension_of ((struct __vtype_parent_m_Parent_t *) opr._vptr, &__vtab_child_m_Child_t))
              {
                __tmp_class_child_t = (struct __class_child_m_Child_t_t *) &opr;
                {
                  struct __class_child_m_Child_t_t * __tmp_class_child_t;

                  switch (rhs->_vptr->_hash)
                    {
                      default:;
                      if (_gfortran_is_extension_of ((struct __vtype_parent_m_Parent_t *) rhs->_vptr, &__vtab_child_m_Child_t))
                        {
                          __tmp_class_child_t = (struct __class_child_m_Child_t_t *) rhs;
                          __tmp_class_child_t->_data->x = lhs->_data->x + __tmp_class_child_t->_data->x;
                          if (lhs->_data->y != 0B && __tmp_class_child_t->_data->y != 0B)
                            {
                              if (__tmp_class_child_t->_data->y != 0B)
                                {
                                  _gfortran_runtime_error_at (&"At line 52 of file src/leaks_raiser_multiple_inheritance_simple.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"__tmp_class_child_t"[1]{lb: 1 sz: 1});
                                }
                              else
                                {
                                  __tmp_class_child_t->_data->y = (integer(kind=4) *) __builtin_malloc (4);
                                  if (__tmp_class_child_t->_data->y == 0B)
                                    {
                                      _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
                                    }
                                }
                              if (__tmp_class_child_t->_data->y != 0B) goto L.34;
                              __tmp_class_child_t->_data->y = (integer(kind=4) *) __builtin_malloc (4);
                              L.34:;
                              *__tmp_class_child_t->_data->y = *lhs->_data->y + *__tmp_class_child_t->_data->y;
                            }
                          L.33:;
                          L.32:;
                        }
                      L.31:;
                      goto L.29;
                    }
                  L.29:;
                  L.28:;
                  L.27:;
                }
                L.26:;
              }
            L.25:;
            goto L.23;
          }
        L.23:;
        L.22:;
        L.21:;
      }
      return opr;
    }
  finally
    {
      opr._data = 0B;
    }
}
```

#### Note

Probably, the failing of workaround is somehow related to the `child_t` finalizer. The code generated is

```c
__final_child_m_Child_t (struct array7_child_t & restrict array, integer(kind=8) byte_stride, logical(kind=1) fini_coarray)
{
  void * restrict D.3555;
  void * restrict D.3559;
  integer(kind=8) idx;
  integer(kind=8) idx2;
  integer(kind=4) ignore;
  logical(kind=4) is_contiguous;
  integer(kind=8) nelem;
  integer(kind=8) offset;
  struct child_t * ptr2;
  integer(kind=8) ubound.0;
  integer(kind=8) size.1;
  integer(kind=8)[0:D.3556] * restrict sizes;
  integer(kind=8) ubound.2;
  integer(kind=8) size.3;
  integer(kind=8)[0:D.3552] * restrict strides;
  integer(kind=4) __result___final_child_m_Chil;
  integer(kind=8) D.3552;
  bitsizetype D.3553;
  sizetype D.3554;
  integer(kind=8) D.3556;
  bitsizetype D.3557;
  sizetype D.3558;

  try
    {
      ubound.0 = (integer(kind=8)) (integer(kind=4)) array->dtype & 7;
      size.1 = ubound.0 + 1;
      size.1 = MAX_EXPR <size.1, 0>;
      D.3556 = size.1 + -1;
      D.3557 = (bitsizetype) (sizetype) NON_LVALUE_EXPR <size.1> * 64;
      D.3558 = (sizetype) NON_LVALUE_EXPR <size.1> * 8;
      D.3559 = (void * restrict) __builtin_malloc (MAX_EXPR <(unsigned long) (size.1 * 8), 1>);
      sizes = (integer(kind=8)[0:D.3556] * restrict) D.3559;
      ubound.2 = (integer(kind=8)) (integer(kind=4)) array->dtype & 7;
      size.3 = NON_LVALUE_EXPR <ubound.2>;
      size.3 = MAX_EXPR <size.3, 0>;
      D.3552 = size.3 + -1;
      D.3553 = (bitsizetype) (sizetype) NON_LVALUE_EXPR <size.3> * 64;
      D.3554 = (sizetype) NON_LVALUE_EXPR <size.3> * 8;
      D.3555 = (void * restrict) __builtin_malloc (MAX_EXPR <(unsigned long) (size.3 * 8), 1>);
      strides = (integer(kind=8)[0:D.3552] * restrict) D.3555;
      __result___final_child_m_Chil = 0;
      is_contiguous = 1;
      (*sizes)[0] = 1;
      {
        integer(kind=8) D.3527;

        D.3527 = (integer(kind=8)) (integer(kind=4)) array->dtype & 7;
        idx = 1;
        if (idx <= D.3527)
          {
            while (1)
              {
                {
                  logical(kind=4) D.3532;

                  (*strides)[NON_LVALUE_EXPR <idx> + -1] = array->dim[idx + -1].stride;
                  {
                    struct array7_child_t * D.3530;

                    D.3530 = (struct array7_child_t *) array;
                    (*sizes)[idx] = (*sizes)[idx + -1] * MAX_EXPR <(D.3530->dim[idx + -1].ubound - D.3530->dim[idx + -1].lbound) + 1, 0>;
                  }
                  if ((*strides)[NON_LVALUE_EXPR <idx> + -1] != (*sizes)[idx + -1])
                    {
                      is_contiguous = 0;
                    }
                  L.3:;
                  L.1:;
                  D.3532 = idx == D.3527;
                  idx = idx + 1;
                  if (D.3532) goto L.2;
                }
              }
          }
        L.2:;
      }
      nelem = (*sizes)[(integer(kind=8)) (integer(kind=4)) array->dtype & 7] + -1;
      {
        integer(kind=8) D.3533;

        D.3533 = nelem;
        idx = 0;
        if (idx <= D.3533)
          {
            while (1)
              {
                {
                  logical(kind=4) D.3551;

                  {
                    integer(kind=8) D.3540;
                    void * D.3541;
                    void * D.3542;
                    static integer(kind=8) C.3543 = 0;
                    integer(kind=8) D.3544;
                    integer(kind=8) D.3545;
                    integer(kind=8) transfer.4;

                    offset = 0;
                    {
                      integer(kind=8) D.3536;

                      D.3536 = (integer(kind=8)) (integer(kind=4)) array->dtype & 7;
                      idx2 = 1;
                      if (idx2 <= D.3536)
                        {
                          while (1)
                            {
                              {
                                logical(kind=4) D.3539;

                                offset = ((idx % (*sizes)[idx2]) / (*sizes)[idx2 + -1]) * (*strides)[NON_LVALUE_EXPR <idx2> + -1] + offset;
                                L.6:;
                                D.3539 = idx2 == D.3536;
                                idx2 = idx2 + 1;
                                if (D.3539) goto L.7;
                              }
                            }
                        }
                      L.7:;
                    }
                    offset = offset * byte_stride;
                    D.3541 = (void *) array->data;
                    D.3542 = D.3541;
                    D.3540 = 8;
                    D.3544 = 8;
                    __builtin_memcpy ((void *) &transfer.4, (void *) &D.3542, (unsigned long) MAX_EXPR <MIN_EXPR <D.3544, D.3540>, 0>);
                    ptr2 = (struct child_t *) (transfer.4 + offset);
                    if (ptr2 != 0B)
                      {
                        {
                          integer(kind=4) stat.5;

                          if (ptr2->y == 0B)
                            {
                              stat.5 = 1;
                            }
                          else
                            {
                              __builtin_free ((void *) ptr2->y);
                              stat.5 = 0;
                            }
                          ptr2->y = 0B;
                          if (stat.5 != 0) goto L.9;
                          L.9:;
                          ignore = stat.5;
                        }
                      }
                    L.8:;
                  }
                  L.4:;
                  D.3551 = idx == D.3533;
                  idx = idx + 1;
                  if (D.3551) goto L.5;
                }
              }
          }
        L.5:;
      }
      __final_parent_m_Parent_t ((struct array7_child_t *) array, byte_stride, fini_coarray);
      return __result___final_child_m_Chil;
    }
  finally
    {
      __builtin_free ((void *) strides);
      __builtin_free ((void *) sizes);
    }
}

```

---

### conclusions

> + The memory leaks generation seems to be related to only the static component of derived types for **only** polymorphic result-functions;
> + the leaks-prone of static component are inherited by children types;
> + a possible **workaround** is to include a **component with the ALLOCATABLE attribute** (even as a dummy, unused variable) in the type whose polymorphic variant is the function result that presently leads to a memory leak.

However, the workaround does **not** always work, as shown by the [multiple inheritance](#multiple_inheritance) test.
